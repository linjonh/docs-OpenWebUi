---
sidebar_position: 1
title: "üö∞ Pipe-Funktion"
---

# üö∞ Pipe-Funktion: Erstellen benutzerdefinierter "Agenten/Modelle"
Willkommen zu dieser Anleitung zum Erstellen von **Pipes** in Open WebUI! Stellen Sie sich Pipes als eine Methode vor, ein neues Modell zu Open WebUI **hinzuzuf√ºgen**. In diesem Dokument werden wir erl√§utern, was ein Pipe ist, wie es funktioniert und wie Sie Ihre eigenen erstellen k√∂nnen, um benutzerdefinierte Logik und Verarbeitung zu Ihren Open WebUI-Modellen hinzuzuf√ºgen. Wir verwenden klare Metaphern und gehen auf jedes Detail ein, um sicherzustellen, dass Sie ein umfassendes Verst√§ndnis haben.


## Einf√ºhrung in Pipes

Stellen Sie sich Open WebUI als ein **Rohrleitungssystem** vor, in dem Daten durch Rohre und Ventile flie√üen. In dieser Analogie:

- **Pipes** sind wie **Plugins**, die es Ihnen erm√∂glichen, neue Datenflusswege einzuf√ºhren und benutzerdefinierte Logik und Verarbeitung einzubringen.
- **Ventile** sind die **konfigurierbaren Teile** Ihrer Pipe, die steuern, wie Daten durch sie flie√üen.

Indem Sie eine Pipe erstellen, erstellen Sie im Wesentlichen ein benutzerdefiniertes Modell mit dem spezifischen Verhalten, das Sie innerhalb des Open WebUI-Frameworks w√ºnschen.

---

## Aufbau der Pipe-Struktur verstehen

Beginnen wir mit einer grundlegenden, simplen Version einer Pipe, um ihren Aufbau zu verstehen:

```python
from pydantic import BaseModel, Field

class Pipe:
    class Valves(BaseModel):
        MODEL_ID: str = Field(default="")

    def __init__(self):
        self.valves = self.Valves()

    def pipe(self, body: dict):
        # Logik hier
        print(self.valves, body)  # Dies gibt die Konfigurationsoptionen und den Eingabebody aus
        return "Hallo, Welt!"
```

### Die Pipe-Klasse

- **Definition**: Die `Pipe`-Klasse ist der Ort, an dem Sie Ihre benutzerdefinierte Logik definieren.
- **Zweck**: Dient als Blaupause f√ºr Ihr Plugin und bestimmt, wie es sich innerhalb von Open WebUI verh√§lt.

### Ventile: Konfiguration Ihrer Pipe

- **Definition**: `Valves` ist eine geschachtelte Klasse innerhalb von `Pipe`, die von `BaseModel` erbt.
- **Zweck**: Sie enth√§lt die Konfigurationsoptionen (Parameter), die bei der Verwendung Ihrer Pipe bestehen bleiben.
- **Beispiel**: Im obigen Code ist `MODEL_ID` eine Konfigurationsoption mit einer leeren Zeichenkette als Standardwert.

**Metapher**: Denken Sie an Ventile als Drehkn√∂pfe eines echten Rohrleitungssystems, die den Wasserfluss steuern. In Ihrer Pipe erm√∂glichen Ventile Benutzern, Einstellungen anzupassen, die beeinflussen, wie die Daten flie√üen und verarbeitet werden.

### Die `__init__`-Methode

- **Definition**: Die Konstruktor-Methode der `Pipe`-Klasse.
- **Zweck**: Initialisiert den Zustand der Pipe und richtet notwendige Komponenten ein.
- **Best Practice**: Halten Sie es einfach; initialisieren Sie hier haupts√§chlich `self.valves`.

```python
def __init__(self):
    self.valves = self.Valves()
```

### Die `pipe`-Funktion

- **Definition**: Die Kernfunktion, in der Ihre benutzerdefinierte Logik enthalten ist.
- **Parameter**:
  - `body`: Ein W√∂rterbuch, das die Eingabedaten enth√§lt.
- **Zweck**: Verarbeitet die Eingabedaten mithilfe Ihrer benutzerdefinierten Logik und gibt das Ergebnis zur√ºck.

```python
def pipe(self, body: dict):
    # Logik hier
    print(self.valves, body)  # Dies gibt die Konfigurationsoptionen und den Eingabebody aus
    return "Hallo, Welt!"
```

**Hinweis**: Platzieren Sie `Valves` immer oben in Ihrer `Pipe`-Klasse, gefolgt von `__init__` und dann der `pipe`-Funktion. Diese Struktur sorgt f√ºr Klarheit und Konsistenz.

---

## Erstellen mehrerer Modelle mit Pipes

Was, wenn Sie m√∂chten, dass Ihre Pipe **mehrere Modelle** innerhalb von Open WebUI erstellt? Sie k√∂nnen dies erreichen, indem Sie eine `pipes`-Funktion oder -Variable innerhalb Ihrer `Pipe`-Klasse definieren. Dieses Setup, informell **Verteiler** genannt, erm√∂glicht es Ihrer Pipe, mehrere Modelle darzustellen.

Folgendes ist m√∂glich:

```python
from pydantic import BaseModel, Field

class Pipe:
    class Valves(BaseModel):
        MODEL_ID: str = Field(default="")

    def __init__(self):
        self.valves = self.Valves()

    def pipes(self):
        return [
            {"id": "model_id_1", "name": "modell_1"},
            {"id": "model_id_2", "name": "modell_2"},
            {"id": "model_id_3", "name": "modell_3"},
        ]

    def pipe(self, body: dict):
        # Logik hier
        print(self.valves, body)  # Gibt die Konfigurationsoptionen und den Eingabebody aus
        model = body.get("model", "")
        return f"{model}: Hallo, Welt!"
```

### Erkl√§rung

- **`pipes`-Funktion**:
  - Gibt eine Liste von W√∂rterb√ºchern zur√ºck.
  - Jedes W√∂rterbuch repr√§sentiert ein Modell mit eindeutigen Schl√ºsseln `id` und `name`.
  - Diese Modelle werden einzeln im Modellauswahlmodus von Open WebUI angezeigt.

- **Erweiterte `pipe`-Funktion**:
  - Verarbeitet Eingaben basierend auf dem ausgew√§hlten Modell.
  - In diesem Beispiel enth√§lt die zur√ºckgegebene Zeichenkette den Modellnamen.

---

## Beispiel: OpenAI Proxy Pipe

Schauen wir uns ein praktisches Beispiel an, bei dem wir eine Pipe erstellen, die Anfragen an die OpenAI API weiterleitet. Diese Pipe ruft verf√ºgbare Modelle von OpenAI ab und erm√∂glicht Benutzern, mit ihnen √ºber Open WebUI zu interagieren.

```python
from pydantic import BaseModel, Field
import requests

class Pipe:
    class Valves(BaseModel):
        NAME_PREFIX: str = Field(
            default="OPENAI/",
            description="Pr√§fix, das vor Modellnamen hinzugef√ºgt wird.",
        )
        OPENAI_API_BASE_URL: str = Field(
            default="https://api.openai.com/v1",
            description="Basis-URL f√ºr den Zugriff auf OpenAI API-Endpunkte.",
        )
        OPENAI_API_KEY: str = Field(
            default="",
            description="API-Schl√ºssel zur Authentifizierung von Anfragen an die OpenAI API.",
        )

    def __init__(self):
        self.valves = self.Valves()

    def pipes(self):
        if self.valves.OPENAI_API_KEY:
            try:
                headers = {
                    "Authorization": f"Bearer {self.valves.OPENAI_API_KEY}",
                    "Content-Type": "application/json",
                }

                r = requests.get(
                    f"{self.valves.OPENAI_API_BASE_URL}/models", headers=headers
                )
                models = r.json()
                return [
                    {
                        "id": model["id"],
                        "name": f{self.valves.NAME_PREFIX}{model.get("name", model["id"])},
                    }
                    for model in models["data"]
                    if "gpt" in model["id"]
                ]

            except Exception as e:
                return [
                    {
                        "id": "error",
                        "name": "Fehler beim Abrufen der Modelle. Bitte √ºberpr√ºfen Sie Ihren API-Schl√ºssel.",
                    },
                ]
        else:
            return [
                {
                    "id": "error",
                    "name": "API-Schl√ºssel nicht bereitgestellt.",
                },
            ]

    def pipe(self, body: dict, __user__: dict):
        print(f"pipe:{__name__}")
        headers = {
            "Authorization": f"Bearer {self.valves.OPENAI_API_KEY}",
            "Content-Type": "application/json",
        }

        # Extrahiere Modell-ID aus dem Modellnamen
        model_id = body["model"][body["model"].find(".") + 1 :]

        # Aktualisiere die Modell-ID im Body
        payload = {**body, "model": model_id}
        try:
            r = requests.post(
                url=f"{self.valves.OPENAI_API_BASE_URL}/chat/completions",
                json=payload,
                headers=headers,
                stream=True,
            )

            r.raise_for_status()

            if body.get("stream", False):
                return r.iter_lines()
            else:
                return r.json()
        except Exception as e:
            return f"Fehler: {e}"
```

### Detaillierte Aufschl√ºsselung

#### Ventilkonfiguration

- **`NAME_PREFIX`**:
  - F√ºgt einen Pr√§fix zu den Modellnamen hinzu, die im Open WebUI angezeigt werden.
  - Standard: `"OPENAI/"`.
- **`OPENAI_API_BASE_URL`**:
  - Gibt die Basis-URL f√ºr die OpenAI API an.
  - Standard: `"https://api.openai.com/v1"`.
- **`OPENAI_API_KEY`**:
  - Ihr OpenAI API-Schl√ºssel zur Authentifizierung.
  - Standard: `""` (leerer String, muss bereitgestellt werden).

#### Die Funktion `pipes`

- **Zweck**: Ruft verf√ºgbare OpenAI-Modelle ab und macht sie im Open WebUI zug√§nglich.

- **Prozessablauf**:
  1. **√úberpr√ºfung des API-Schl√ºssels**: Stellt sicher, dass ein API-Schl√ºssel bereitgestellt wird.
  2. **Abrufen von Modellen**: F√ºhrt eine GET-Anfrage an die OpenAI API aus, um verf√ºgbare Modelle abzurufen.
  3. **Filterung von Modellen**: Gibt Modelle zur√ºck, die `"gpt"` in ihrer `id` enthalten.
  4. **Fehlerbehandlung**: Gibt im Falle eines Problems eine Fehlermeldung zur√ºck.

- **R√ºckgabeformat**: Eine Liste von Dictionaries mit `id` und `name` f√ºr jedes Modell.

#### Die Funktion `pipe`

- **Zweck**: Bearbeitet die Anfrage an das ausgew√§hlte OpenAI-Modell und gibt die Antwort zur√ºck.

- **Parameter**:
  - `body`: Enth√§lt die Anfragedaten.
  - `__user__`: Enth√§lt Informationen zum Benutzer (wird in diesem Beispiel nicht verwendet, kann jedoch f√ºr Authentifizierungs- oder Protokollierungszwecke n√ºtzlich sein).

- **Prozessablauf**:
  1. **Vorbereitung der Header**: Erstellt Header mit API-Schl√ºssel und Inhalts-Typ.
  2. **Extrahieren der Modell-ID**: Extrahiert die tats√§chliche Modell-ID aus dem ausgew√§hlten Modellnamen.
  3. **Payload vorbereiten**: Aktualisiert den Body mit der korrekten Modell-ID.
  4. **API-Anfrage ausf√ºhren**: Sendet eine POST-Anfrage an die Chat Completions Endpoint der OpenAI API.
  5. **Streaming behandeln**: Falls `stream` `True` ist, gibt eine iterierbare der Zeilen zur√ºck.
  6. **Fehlerbehandlung**: F√§ngt Ausnahmen ab und gibt eine Fehlermeldung zur√ºck.

### Erweiterung der Proxy-Pipe

Sie k√∂nnen diese Proxy-Pipe anpassen, um zus√§tzliche Diensteanbieter wie Anthropic, Perplexity und mehr zu unterst√ºtzen, indem Sie die API-Endpunkte, Header und Logik in den Funktionen `pipes` und `pipe` √§ndern.

---

## Verwendung interner Open WebUI-Funktionen

Manchmal m√∂chten Sie m√∂glicherweise die internen Funktionen des Open WebUI innerhalb Ihrer Pipe verwenden. Sie k√∂nnen diese Funktionen direkt aus dem `open_webui`-Paket importieren. Beachten Sie, dass interne Funktionen sich m√∂glicherweise √§ndern k√∂nnen, um Optimierungen vorzunehmen. Konsultieren Sie daher stets die neueste Dokumentation.

So k√∂nnen Sie interne Open WebUI-Funktionen verwenden:

```python
from pydantic import BaseModel, Field
from fastapi import Request

from open_webui.models.users import Users
aus open_webui.utils.chat import generate_chat_completion

klasse Rohr:
    def __init__(self):
        pass

    async def Rohrleitung(
        selbst,
        body: dict,
        __user__: dict,
        __request__: Anfrage,
    ) -> str:
        # Verwenden Sie den einheitlichen Endpunkt mit der aktualisierten Signatur
        Benutzer = Users.get_user_by_id(__user__["id"])
        body["model"] = "llama3.2:neueste"
        return await generate_chat_completion(__request__, body, user)
```

### Erkl√§rung

- **Importe**:
  - `Users` aus `open_webui.models.users`: Um Benutzerinformationen abzurufen.
  - `generate_chat_completion` aus `open_webui.utils.chat`: Um Chat-Antworten anhand interner Logik zu generieren.

- **Asynchrone `Rohrleitung` Funktion**:
  - **Parameter**:
    - `body`: Input-Daten f√ºr das Modell.
    - `__user__`: Dictionary, das Benutzerinformationen enth√§lt.
    - `__request__`: Das Anforderungsobjekt von FastAPI (erforderlich f√ºr `generate_chat_completion`).
  - **Prozess**:
    1. **Benutzerobjekt abrufen**: Ruft das Benutzerobjekt anhand seiner ID ab.
    2. **Modell festlegen**: Gibt das zu verwendende Modell an.
    3. **Abschluss generieren**: Ruft `generate_chat_completion` auf, um den Input zu verarbeiten und eine Ausgabe zu erstellen.

### Wichtige Hinweise

- **Funktionssignaturen**: Weitere Informationen finden Sie in der neuesten Open WebUI-Codebasis oder Dokumentation.
- **Best Practices**: Fehler und Ausnahmen immer sorgf√§ltig behandeln, um eine reibungslose Benutzererfahrung zu gew√§hrleisten.

---

## H√§ufig gestellte Fragen

### F1: Warum sollte ich Rohre in Open WebUI verwenden?

**A**: Rohre erm√∂glichen es Ihnen, neue "Modelle" mit benutzerdefinierter Logik und Verarbeitung zu Open WebUI hinzuzuf√ºgen. Es handelt sich um ein flexibles Plug-in-System, mit dem Sie externe APIs integrieren, Modellverhalten anpassen und innovative Funktionen erstellen k√∂nnen, ohne die Kern-Codebasis zu √§ndern.

---

### F2: Was sind Ventile und warum sind sie wichtig?

**A**: Ventile sind die konfigurierbaren Parameter Ihres Rohres. Sie fungieren wie Einstellungen oder Steuerungen, die bestimmen, wie Ihr Rohr funktioniert. Durch das Anpassen von Ventilen k√∂nnen Sie das Verhalten Ihres Rohres √§ndern, ohne den zugrunde liegenden Code zu modifizieren.

---

### F3: Kann ich ein Rohr ohne Ventile erstellen?

**A**: Ja, Sie k√∂nnen ein einfaches Rohr erstellen, ohne eine Ventilklasse zu definieren, wenn Ihr Rohr keine dauerhaften Konfigurationsoptionen ben√∂tigt. Das Hinzuf√ºgen von Ventilen ist jedoch eine gute Praxis f√ºr Flexibilit√§t und zuk√ºnftige Skalierbarkeit.

---

### F4: Wie stelle ich sicher, dass mein Rohr beim Einsatz von API-Schl√ºsseln sicher ist?

**A**: Hartecodieren Sie niemals sensible Informationen wie API-Schl√ºssel in Ihr Rohr. Verwenden Sie stattdessen Ventile zum sicheren Eingeben und Speichern von API-Schl√ºsseln. Stellen Sie sicher, dass Ihr Code diese Schl√ºssel richtig behandelt und ihre Protokollierung oder Offenlegung vermeidet.

---

### F5: Was ist der Unterschied zwischen den Funktionen `Rohrleitung` und `Rohrleitungen`?

**A**:

- **`Rohrleitung` Funktion**: Die Hauptfunktion, in der Sie die Eingangsdaten verarbeiten und eine Ausgabe generieren. Sie bearbeitet die Logik f√ºr ein einzelnes Modell.

- **`Rohrleitungen` Funktion**: Erm√∂glicht es Ihrem Rohr, mehrere Modelle darzustellen, indem eine Liste von Modelldefinitionen zur√ºckgegeben wird. Jedes Modell wird einzeln in Open WebUI angezeigt.

---

### F6: Wie kann ich Fehler in meinem Rohr behandeln?

**A**: Verwenden Sie Try-Except-Bl√∂cke in Ihren `Rohrleitung` und `Rohrleitungen` Funktionen, um Ausnahmen abzufangen. Geben Sie aussagekr√§ftige Fehlermeldungen zur√ºck oder behandeln Sie die Fehler auf elegante Weise, um den Benutzer √ºber das Problem zu informieren.

---

### F7: Kann ich externe Bibliotheken in meinem Rohr verwenden?

**A**: Ja, Sie k√∂nnen bei Bedarf externe Bibliotheken importieren und verwenden. Stellen Sie sicher, dass alle Abh√§ngigkeiten ordnungsgem√§√ü installiert und in Ihrer Umgebung verwaltet werden.

---

### F8: Wie teste ich mein Rohr?

**A**: Testen Sie Ihr Rohr, indem Sie Open WebUI in einer Entwicklungsumgebung ausf√ºhren und Ihr benutzerdefiniertes Modell aus der Benutzeroberfl√§che ausw√§hlen. Validieren Sie, dass sich Ihr Rohr wie erwartet mit verschiedenen Eingaben und Konfigurationen verh√§lt.

---

### F9: Gibt es Best Practices f√ºr die Organisation des Codes meines Rohres?

**A**: Ja, folgen Sie diesen Richtlinien:

- Platzieren Sie `Ventile` oben in Ihrer `Rohr` Klasse.
- Initialisieren Sie Variablen in der `__init__` Methode, insbesondere `self.valves`.
- Platzieren Sie die `Rohrleitung` Funktion nach der `__init__` Methode.
- Verwenden Sie klare und beschreibende Variablennamen.
- Kommentieren Sie Ihren Code f√ºr bessere Verst√§ndlichkeit.

---

### F10: Wo finde ich die neueste Open WebUI-Dokumentation?

**A**: Besuchen Sie das offizielle Open WebUI-Repository oder die Dokumentationsseite f√ºr die neuesten Informationen, einschlie√ülich Funktionssignaturen, Beispiele und Migrationshilfen, falls √Ñnderungen auftreten.

---

## Fazit

Bis jetzt sollten Sie ein umfassendes Verst√§ndnis davon haben, wie Sie Rohre in Open WebUI erstellen und verwenden. Rohre bieten eine leistungsstarke M√∂glichkeit, die Funktionen von Open WebUI zu erweitern und anzupassen, um Ihren spezifischen Anforderungen gerecht zu werden. Egal, ob Sie externe APIs integrieren, neue Modelle hinzuf√ºgen oder komplexe Logik einf√ºgen, Rohre bieten die Flexibilit√§t, dies zu erm√∂glichen.

Denken Sie daran:

- **Eine klare und konsistente Struktur** in Ihren Rohrklassen zu verwenden.
- **Ventile nutzen**, um konfigurierbare Optionen zu erm√∂glichen.
- **Fehler elegant behandeln**, um die Benutzererfahrung zu verbessern.
- **Konsultieren Sie die neueste Dokumentation** f√ºr Aktualisierungen oder √Ñnderungen.

Viel Spa√ü beim Programmieren und beim Erweitern Ihrer Open WebUI mit Pipes!

---
sidebar_position: 3
title: "üîÑ Ventile"
---

## Ventile

Ventile und BenutzerVentile werden verwendet, um Benutzern zu erm√∂glichen, dynamische Angaben wie einen API-Schl√ºssel oder eine Konfigurationsoption bereitzustellen. Diese erstellen ein ausf√ºllbares Feld oder einen Bool-Schalter im GUI-Men√º f√ºr die jeweilige Funktion. Sie sind immer optional, aber DRINGEND empfohlen.

Daher k√∂nnen Ventile und BenutzerVentile Klassen entweder in einer `Pipe`, `Pipeline`, `Filter` oder `Tools` Klasse definiert werden.

Ventile k√∂nnen ausschlie√ülich von Administratoren √ºber die Tools- oder Funktionsmen√ºs konfiguriert werden. BenutzerVentile hingegen k√∂nnen direkt von jedem Benutzer aus einer Chat-Sitzung konfiguriert werden.

<details>
<summary>Kommentiertes Beispiel</summary>

```python

from pydantic import BaseModel, Field
from typing import Literal

# Definieren und Ventile
class Filter:
   # Beachten Sie die aktuelle Einr√ºckung: Ventile und BenutzerVentile m√ºssen als
   # Attribute einer Tools-, Filter- oder Pipe-Klasse deklariert werden. Hier nehmen wir
   # das Beispiel eines Filters.
    class Ventile(BaseModel):
       # Ventile und BenutzerVentile erben von pydantics BaseModel. Dies
       # erm√∂glicht komplexe Anwendungsf√§lle wie Modellvalidierungen usw.
       test_ventil: int = Field(  # Beachten Sie den Typ-Hinweis: Dieser wird verwendet,
           # um die Art des UI-Elements auszuw√§hlen, das dem Benutzer angezeigt wird (Schaltfl√§chen,
           # Texte usw.).
           default=4,
           description="Ein Ventil, das einen numerischen Wert steuert"
           # required=False,  # Sie k√∂nnen Felder mit True erzwingen
       )
       # Um dem Benutzer die Wahl zwischen mehreren Zeichenketten zu geben, k√∂nnen Sie Literal von typing verwenden:
       wahl_option: Literal["wahlA", "wahlB"] = Field(
           default="wahlA",
           description="Ein Beispiel f√ºr ein Ventil mit mehreren Optionen",
       )
       priorit√§t: int = Field(
           default=0,
           description="Priorit√§tsstufe f√ºr die Filteroperationen. Niedrigere Werte werden zuerst verarbeitet"
       )
       # Das Priorit√§tsfeld ist optional, wird jedoch verwendet, wenn es vorhanden ist,
       # um die Filter zu ordnen.
       pass
       # Beachten Sie, dass dieses pass bei der Analyse hilft und empfohlen wird.

   # BenutzerVentile werden auf dieselbe Weise definiert.
    class BenutzerVentile(BaseModel):
        test_benutzer_ventil: bool = Field(
            default=False, description="Ein BenutzerVentil, das einen Schalter f√ºr Wahr/Falsch (ein/aus) steuert"
        )
        pass

   def __init__(self):
       self.ventile = self.Ventile()
       # Da sie vom Administrator eingestellt werden, sind sie direkt verf√ºgbar
       # bei der Codeausf√ºhrung.
       pass

   # Die inlet-Methode wird nur f√ºr Filter verwendet, aber die __user__-Behandlung ist dieselbe
   def inlet(self, body: dict, __user__: dict):
       # Da BenutzerVentile pro Benutzer definiert werden, sind sie nur verf√ºgbar
       # im Gebrauch.
       # Beachten Sie, dass obwohl __user__ ein dict ist, __user__["ventile"] ein
       # BenutzerVentile-Objekt ist. Daher k√∂nnen Sie Werte wie folgt zugreifen:
       test_benutzer_ventil = __user__["ventile"].test_benutzer_ventil
       # Oder:
       test_benutzer_ventil = dict(__user__["ventile"])["test_benutzer_ventil"]
       # Aber dies wird den Standardwert anstelle des tats√§chlichen Wertes zur√ºckgeben:
       # test_benutzer_ventil = __user__["ventile"]["test_benutzer_ventil"]  # Tun Sie das nicht!
```

</details>

---
sidebar_position: 3
title: "‚õëÔ∏è Ereignisse"
---

# ‚õëÔ∏è Ereignisse: Verwendung von `__event_emitter__` und `__event_call__` in Open WebUI

Open WebUIs Plug-in-Architektur ist nicht nur darauf ausgelegt, Eingaben zu verarbeiten und Ausgaben zu erzeugen‚Äî**es geht um Echtzeitkommunikation und interaktive Kommunikation mit der Benutzeroberfl√§che und den Benutzern**. Um Ihre Tools, Funktionen und Pipes dynamischer zu gestalten, bietet Open WebUI ein integriertes Ereignissystem √ºber die Helfer `__event_emitter__` und `__event_call__`.

Diese Anleitung erkl√§rt **was Ereignisse sind**, **wie man sie aus dem Code ausl√∂sen kann**, und **den vollst√§ndigen Katalog von Ereignistypen**, die Sie verwenden k√∂nnen (einschlie√ülich weit mehr als nur `"input"`).

---

## üåä Was sind Ereignisse?

**Ereignisse** sind Echtzeitbenachrichtigungen oder interaktive Anfragen, die von Ihrem Backend-Code (Tool oder Funktion) an die Web-Oberfl√§che gesendet werden. Sie erm√∂glichen es Ihnen, den Chat zu aktualisieren, Benachrichtigungen anzuzeigen, Best√§tigungen einzuholen, UI-Prozesse auszuf√ºhren und mehr.

- Ereignisse werden mit dem `__event_emitter__`-Helfer f√ºr einseitige Updates gesendet oder `__event_call__`, wenn Benutzereingaben oder eine Antwort ben√∂tigt werden (z. B. Best√§tigung, Eingabe usw.).

**Metapher:**  
Stellen Sie sich Ereignisse wie Push-Benachrichtigungen und modale Dialoge vor, die Ihr Plug-in ausl√∂sen kann, um das Chat-Erlebnis reicher und interaktiver zu gestalten.

---

## üß∞ Grundlegende Nutzung

### Senden eines Ereignisses

Sie k√∂nnen ein Ereignis √ºberall innerhalb Ihres Tools oder Ihrer Funktion ausl√∂sen, indem Sie Folgendes aufrufen:

```python
await __event_emitter__(
    {
        "type": "status",  # Siehe die unten stehende Liste der Ereignistypen
        "data": {
            "description": "Verarbeitung gestartet!",
            "done": False,
            "hidden": False,
        },
    }
)
```

Sie **m√ºssen nicht** manuell Felder wie `chat_id` oder `message_id` hinzuf√ºgen‚Äîdiese werden von Open WebUI automatisch verarbeitet.

### Interaktive Ereignisse

Wenn Sie die Ausf√ºhrung bis zur Benutzerantwort pausieren m√ºssen (z. B. Best√§tigungs-/Abbruch-Dialoge, Code-Ausf√ºhrung oder Eingabe), verwenden Sie `__event_call__`:

```python
result = await __event_call__(
    {
        "type": "input",  # Oder "confirmation", "execute"
        "data": {
            "title": "Bitte geben Sie Ihr Passwort ein",
            "message": "Passwort ist f√ºr diese Aktion erforderlich",
            "placeholder": "Ihr Passwort hier",
        },
    }
)
# result enth√§lt den vom Benutzer eingegebenen Wert
```

---

## üìú Struktur der Ereignis-Nutzlast

Wenn Sie ein Ereignis senden oder aufrufen, sieht die grundlegende Struktur so aus:

```json
{
  "type": "event_type",   // Siehe vollst√§ndige Liste unten
  "data": { ... }         // Ereignisspezifische Nutzlast
}
```

Meistens legen Sie nur `"type"` und `"data"` fest. Open WebUI f√ºllt die Routing-Daten automatisch aus.

---

## üóÇ Vollst√§ndige Liste der Ereignistypen

Nachfolgend finden Sie eine umfassende Tabelle aller unterst√ºtzten `type`-Werte f√ºr Ereignisse sowie deren beabsichtigten Effekt und Datenstruktur. (Basierend auf einer aktuellen Analyse der Open WebUI-Ereignislogik.)

| type                        | Wann verwenden                                | Struktur der Daten-Nutzlast (Beispiele)                            |
|-----------------------------|-----------------------------------------------|--------------------------------------------------------------------|
| `status`                    | Zeigt ein Statusupdate/Verlauf f√ºr eine Nachricht | `{description: ..., done: bool, hidden: bool}`                     |
| `chat:completion`           | Bietet ein Chat-Vervollst√§ndigungs-Ergebnis   | (Benutzerdefiniert, siehe Open WebUI-Interna)                      |
| `chat:message:delta`,<br/>`message` | F√ºgt Inhalt zur aktuellen Nachricht hinzu              | `{content: "Text zum Hinzuf√ºgen"}`                                |
| `chat:message`,<br/>`replace`        | Ersetzt den aktuellen Nachrichtentext vollst√§ndig      | `{content: "Ersetzungstext"}`                                     |
| `chat:message:files`,<br/>`files`   | Setzt oder √ºberschreibt Nachrichtendateien (f√ºr Uploads, Ausgaben) | `{files: [...]}`                                                   |
| `chat:title`                | Setzt (oder aktualisiert) den Chat-Titel      | Themenstring ODER `{title: ...}`                                   |
| `chat:tags`                 | Aktualisiert die Tag-Sammlung f√ºr einen Chat  | Tag-Array oder Objekt                                              |
| `source`,<br/>`citation`              | F√ºgt eine Quelle/Zitation oder ein Codeausf√ºhrungsergebnis hinzu | F√ºr Code: Siehe [unten.](#code-execution-event)                    |
| `notification`              | Zeigt eine Benachrichtigung ("Toast") in der UI an | `{type: "info" oder "success" oder "error" oder "warning", content: "..."}` |
| `confirmation` <br/>(ben√∂tigt `__event_call__`) | Fragt nach Best√§tigung (OK/Abbrechen-Dialog)   | `{title: "...", message: "..."}`                                   |
| `input` <br/>(ben√∂tigt `__event_call__`)    | Fordert einfache Benutzereingabe ("Eingabefeld"-Dialog) | `{title: "...", message: "...", placeholder: "...", value: ...}` |
| `execute` <br/>(ben√∂tigt `__event_call__`)  | Fordere die Ausf√ºhrung benutzerseitigen Codes an und gib das Ergebnis zur√ºck  | `{code: "...Javascript-Code..."}`                                  |

**Andere/Fortgeschrittene Typen:**

- Sie k√∂nnen Ihre eigenen Typen definieren und diese in der UI-Schicht behandeln (oder bevorstehende Mechanismen zur Ereigniserweiterung nutzen).

### ‚ùó Details zu spezifischen Ereignistypen
### `status`

Zeige einen Status-/Fortschritts-Update in der UI:

```python
await __event_emitter__(
    {
        "type": "status",
        "data": {
            "description": "Schritt 1/3: Daten werden abgerufen...",
            "done": False,
            "hidden": False,
        },
    }
)
```

---

### `chat:message:delta` oder `message`

**Streaming-Ausgabe** (Text anh√§ngen):

```python
await __event_emitter__(
    {
        "type": "chat:message:delta",  # oder einfach "message"
        "data": {
            "content": "Teiltext, "
        },
    }
)

# Sp√§ter, w√§hrend weitere generiert werden:
await __event_emitter__(
    {
        "type": "chat:message:delta",
        "data": {
            "content": "n√§chster Teil der Antwort."
        },
    }
)
```

---

### `chat:message` oder `replace`

**Setze (oder ersetze) den gesamten Nachrichteninhalt:**

```python
await __event_emitter__(
    {
        "type": "chat:message",  # oder "replace"
        "data": {
            "content": "Abschlie√üende, vollst√§ndige Antwort."
        },
    }
)
```

---

### `files` oder `chat:message:files`

**Dateien anh√§ngen oder aktualisieren:**

```python
await __event_emitter__(
    {
        "type": "files",  # oder "chat:message:files"
        "data": {
            "files": [
               # Open WebUI File Objects
            ]
        },
    }
)
```

---

### `chat:title`

**Aktualisiere den Titel des Chats:**

```python
await __event_emitter__(
    {
        "type": "chat:title",
        "data": {
            "title": "Marktanalyse-Bot-Session"
        },
    }
)
```

---

### `chat:tags`

**Aktualisiere die Tags des Chats:**

```python
await __event_emitter__(
    {
        "type": "chat:tags",
        "data": {
            "tags": ["Finanzen", "KI", "Tagesbericht"]
        },
    }
)
```

---

### `source` oder `citation` (und Codeausf√ºhrung)

**F√ºge eine Referenz/Zitierung hinzu:**

```python
await __event_emitter__(
    {
        "type": "source",  # oder "citation"
        "data": {
            # Open WebUI Source (Citation) Object
        }
    }
)
```

**F√ºr Codeausf√ºhrung (Verfolgung des Ausf√ºhrungsstatus):**

```python
await __event_emitter__(
    {
        "type": "source",
        "data": {
            # Open WebUI Code Source (Citation) Object
        }
    }
)
```

---

### `notification`

**Zeige eine Toast-Benachrichtigung:**

```python
await __event_emitter__(
    {
        "type": "notification",
        "data": {
            "type": "info",  # "success", "warning", "error"
            "content": "Der Vorgang wurde erfolgreich abgeschlossen!"
        }
    }
)
```

---

### `confirmation` (**erfordert** `__event_call__`)

**Zeige einen Best√§tigungsdialog und erfasse die Benutzerantwort:**

```python
result = await __event_call__(
    {
        "type": "confirmation",
        "data": {
            "title": "Sind Sie sicher?",
            "message": "M√∂chten Sie wirklich fortfahren?"
        }
    }
)

if result:  # oder pr√ºfen Sie den Inhalt des Ergebnisses
    await __event_emitter__({
        "type": "notification",
        "data": {"type": "success", "content": "Benutzer hat die Operation best√§tigt."}
    })
else:
    await __event_emitter__({
        "type": "notification",
        "data": {"type": "warning", "content": "Benutzer hat abgebrochen."}
    })
```

---

### `input` (**erfordert** `__event_call__`)

**Fordere den Benutzer zur Eingabe von Text auf:**

```python
result = await __event_call__(
    {
        "type": "input",
        "data": {
            "title": "Geben Sie Ihren Namen ein",
            "message": "Wir ben√∂tigen Ihren Namen, um fortzufahren.",
            "placeholder": "Ihr vollst√§ndiger Name"
        }
    }
)

user_input = result
await __event_emitter__(
    {
        "type": "notification",
        "data": {"type": "info", "content": f"Sie haben eingegeben: {user_input}"}
    }
)
```

---

### `execute` (**erfordert** `__event_call__`)

**F√ºhre Code dynamisch auf der Benutzerseite aus:**

```python
result = await __event_call__(
    {
        "type": "execute",
        "data": {
            "code": "print(40 + 2);",
        }
    }
)

await __event_emitter__(
    {
        "type": "notification",
        "data": {
            "type": "info",
            "content": f"Code ausgef√ºhrt, Ergebnis: {result}"
        }
    }
)
```

---

## üèóÔ∏è Wann & wo Ereignisse verwenden

- **Von jedem Werkzeug oder jeder Funktion** in Open WebUI.
- Um **Antworten zu streamen**, Fortschritte anzuzeigen, Benutzerdaten anzufordern, die UI zu aktualisieren oder erg√§nzende Informationen/Dateien anzuzeigen.
- `await __event_emitter__` ist f√ºr Einweg-Nachrichten (fire and forget).
- `await __event_call__` ist, wenn Sie eine Antwort vom Benutzer ben√∂tigen (Eingabe, Ausf√ºhrung, Best√§tigung).

---

## üí° Tipps & Fortgeschrittene Hinweise

- **Mehrere Typen pro Nachricht:** Sie k√∂nnen mehrere Ereignisse verschiedener Typen f√ºr eine Nachricht senden ‚Äì beispielsweise `status`-Updates anzeigen, dann mit `chat:message:delta` streamen und schlie√ülich mit einem `chat:message` abschlie√üen.
- **Benutzerdefinierte Ereignistypen:** Obwohl die obige Liste der Standard ist, k√∂nnen Sie Ihre eigenen Typen verwenden und in benutzerdefiniertem UI-Code erkennen/behandeln.
- **Erweiterbarkeit:** Das Ereignissystem ist darauf ausgelegt, sich weiterzuentwickeln‚Äî√ºberpr√ºfen Sie immer die [Open WebUI-Dokumentation](https://github.com/open-webui/open-webui) f√ºr die aktuellste Liste und fortgeschrittene Nutzung.

---

## üßê FAQ

### F: Wie kann ich eine Benachrichtigung f√ºr den Benutzer ausl√∂sen?
Verwenden Sie den `notification` Typ:
```python
await __event_emitter__({
    "type": "notification",
    "data": {"type": "success", "content": "Aufgabe abgeschlossen"}
})
```

### F: Wie kann ich den Benutzer nach einer Eingabe fragen und seine Antwort erhalten?
Verwenden Sie:
```python
response = await __event_call__({
    "type": "input",
    "data": {
        "title": "Wie hei√üt du?",
        "message": "Bitte geben Sie Ihren bevorzugten Namen ein:",
        "placeholder": "Name"
    }
})
# Die Antwort wird sein: {"value": "Antwort des Benutzers"}
```

### F: Welche Ereignistypen stehen f√ºr `__event_call__` zur Verf√ºgung?
- `"input"`: Eingabebox-Dialog
- `"confirmation"`: Ja/Nein, OK/Abbrechen-Dialog
- `"execute"`: Ausf√ºhrung des bereitgestellten Codes auf dem Client und R√ºckgabe des Ergebnisses

### F: Kann ich Dateien aktualisieren, die an eine Nachricht angeh√§ngt sind?
Ja‚Äîverwenden Sie den Ereignistyp `"files"` oder `"chat:message:files"` mit einer `{files: [...]}`-Nutzlast.

### F: Kann ich den Konversationstitel oder Tags aktualisieren?
Auf jeden Fall: Verwenden Sie entsprechend `"chat:title"` oder `"chat:tags"`.

### F: Kann ich Antworten (Teiltokens) an den Benutzer streamen?
Ja‚Äîl√∂sen Sie `"chat:message:delta"`-Ereignisse in einer Schleife aus und schlie√üen Sie mit `"chat:message"` ab.

---

## üìù Fazit

**Ereignisse** geben Ihnen Echtzeit-, interaktive Superkr√§fte in Open WebUI. Sie erm√∂glichen es Ihrem Code, Inhalte zu aktualisieren, Benachrichtigungen auszul√∂sen, Benutzereingaben anzufordern, Ergebnisse zu streamen, Code zu verarbeiten und vieles mehr‚Äînahtlos Ihre Backend-Intelligenz mit der Chat-UI zu verbinden.

- Verwenden Sie `__event_emitter__` f√ºr einseitige Status-/Inhaltsaktualisierungen.
- Verwenden Sie `__event_call__` f√ºr Interaktionen, die eine Benutzerantwort erfordern (Eingabe, Best√§tigung, Ausf√ºhrung).

Siehe in diesem Dokument die g√§ngigen Ereignistypen und Strukturen und erkunden Sie den Quellcode oder die Dokumentation von Open WebUI f√ºr aktuelle Updates oder benutzerdefinierte Ereignisse!

---

**Viel Spa√ü beim ereignisgesteuerten Programmieren in Open WebUI! üöÄ**
---
sidebar_position: 2
title: "üõ†Ô∏è Entwicklung"
---



## Schreiben eines benutzerdefinierten Toolkits

Toolkits werden in einer einzigen Python-Datei definiert, mit einer obersten Docstring-Ebene, die Metadaten enth√§lt, und einer `Tools`-Klasse.

### Beispiel oberster Docstring

```python
"""
title: Zeichenkettenumkehr
author: Dein Name
author_url: https://website.com
git_url: https://github.com/username/string-reverse.git
description: Dieses Tool berechnet die Umkehrung einer Zeichenkette
required_open_webui_version: 0.4.0
requirements: langchain-openai, langgraph, ollama, langchain_ollama
version: 0.4.0
licence: MIT
"""
```

### Tools-Klasse

Tools m√ºssen als Methoden innerhalb einer `Tools`-Klasse definiert werden, mit optionalen Unterklassen namens `Valves` und `UserValves`, zum Beispiel:

```python
class Tools:
    def __init__(self):
        """Initialisierung des Tools."""
        self.valves = self.Valves()

    class Valves(BaseModel):
        api_key: str = Field("", description="Ihr API-Schl√ºssel hier")

    def reverse_string(self, string: str) -> str:
        """
        Kehrt die Eingabezeichenkette um.
        :param string: Die zu umkehrende Zeichenkette
        """
        # Beispiel f√ºr die Verwendung von Ventilen
        if self.valves.api_key != "42":
            return "Falscher API-Schl√ºssel"
        return string[::-1] 
```

### Typisierungen
Jedes Tool muss Typisierungen f√ºr Argumente haben. Die Typen k√∂nnen auch geschachtelt sein, wie `queries_and_docs: list[tuple[str, int]]`. Diese Typisierungen werden verwendet, um das JSON-Schema zu generieren, das an das Modell gesendet wird. Tools ohne Typisierungen arbeiten mit wesentlich weniger Konsistenz.

### Ventile und Benutzerventile - (optional, aber SEHR empfehlenswert)

Ventile und Benutzerventile werden verwendet, um anpassbare Einstellungen des Tools anzugeben. Sie k√∂nnen mehr auf der dedizierten Seite [Valves & UserValves](../valves/index.mdx) lesen.

### Optionale Argumente
Nachfolgend eine Liste optionaler Argumente, auf die Ihre Tools angewiesen sein k√∂nnen:
- `__event_emitter__`: Ereignisse ausl√∂sen (siehe folgenden Abschnitt)
- `__event_call__`: Das Gleiche wie der Ereignisemitter, kann jedoch f√ºr Benutzerinteraktionen verwendet werden
- `__user__`: Ein W√∂rterbuch mit Benutzerinformationen. Es enth√§lt auch das `UserValves`-Objekt in `__user__["valves"]`.
- `__metadata__`: W√∂rterbuch mit Chat-Metadaten
- `__messages__`: Liste vorheriger Nachrichten
- `__files__`: Anh√§nge
- `__model__`: Ein W√∂rterbuch mit Modellinformationen

F√ºgen Sie diese einfach wie `__user__` im obigen Beispiel als Argument zu jeder Methode Ihrer Tool-Klasse hinzu.

### Ereignisemitter
Ereignisemitter werden verwendet, um zus√§tzliche Informationen zur Chat-Oberfl√§che hinzuzuf√ºgen. √Ñhnlich wie Filter-Ausg√§nge k√∂nnen Ereignisemitter Inhalte dem Chat hinzuf√ºgen. Im Gegensatz zu Filter-Ausg√§ngen k√∂nnen sie keine Informationen entfernen. Dar√ºber hinaus k√∂nnen Emitter in jedem Stadium w√§hrend des Tools aktiviert werden.

Es gibt zwei verschiedene Typen von Ereignisemitteln:

Wenn das Modell anscheinend nicht in der Lage ist, das Tool aufzurufen, stellen Sie sicher, dass es aktiviert ist (entweder √ºber die Modell-Seite oder √ºber das `+`-Zeichen neben dem Chat-Eingabefeld). Sie k√∂nnen auch das Argument `Function Calling` im Abschnitt `Erweiterte Parameter` auf der Modell-Seite von `Standard` auf `Native` umstellen.

#### Status
Dies wird verwendet, um Status zu einer Nachricht hinzuzuf√ºgen, w√§hrend sie Schritte ausf√ºhrt. Dies kann in jedem Stadium w√§hrend des Tools erfolgen. Diese Status erscheinen direkt √ºber dem Nachrichtentext. Sie sind besonders n√ºtzlich f√ºr Tools, die die LLM-Antwort verz√∂gern oder gro√üe Informationsmengen verarbeiten. Auf diese Weise k√∂nnen Sie Benutzer in Echtzeit dar√ºber informieren, was verarbeitet wird.

```python
await __event_emitter__(
            {
                "type": "status", # Wir setzen hier den Typ
                "data": {"description": "Nachricht, die im Chat angezeigt wird", "done": False, "hidden": False}, 
                # Beachten Sie, hier ist done auf False gesetzt, was darauf hinweist, dass wir weiterhin Status senden
            }
        )
```

<details>
<summary>Beispiel</summary>

```python
async def test_function(
        self, prompt: str, __user__: dict, __event_emitter__=None
    ) -> str:
        """
        Dies ist eine Demo

        :param test: Dies ist ein Test-Parameter
        """

        await __event_emitter__(
            {
                "type": "status", # Wir setzen hier den Typ
                "data": {"description": "Nachricht, die im Chat angezeigt wird", "done": False}, 
                # Beachten Sie, hier ist done auf False gesetzt, was darauf hinweist, dass wir weiterhin Status senden
            }
        )

        # Hier kann andere Logik ausgef√ºhrt werden
        await __event_emitter__(
            {
                "type": "status",
                "data": {"description": "Abgeschlossene Aufgabe Nachricht", "done": True, "hidden": False},
                # Beachten Sie, hier ist done auf True gesetzt, was darauf hinweist, dass wir keine Status mehr senden
                # Sie k√∂nnen auch "hidden": True setzen, wenn Sie den Status entfernen m√∂chten, sobald die Nachricht zur√ºckgegeben wird
            }
        )

        except Exception as e:
            await __event_emitter__(
                {
                    "type": "status",
                    "data": {"description": f"Ein Fehler ist aufgetreten: {e}", "done": True},
                }
            )

            return f"Dem Benutzer mitteilen: {e}"
```
</details>

#### Nachricht
Dieser Typ wird verwendet, um zu jedem Zeitpunkt im Tool eine Nachricht an das LLM anzuh√§ngen. Das bedeutet, dass Sie Nachrichten anh√§ngen, Bilder einbetten und sogar Webseiten vor, nach oder w√§hrend der LLM-Antwort rendern k√∂nnen.

```python
await __event_emitter__(
                    {
                        "type": "message", # Wir setzen hier den Typ
                        "data": {"content": "Diese Nachricht wird dem Chat hinzugef√ºgt."},
                        # Beachten Sie, dass wir bei Nachrichtentypen keine Bedingung f√ºr "done" setzen m√ºssen
                    }
                )
```

<details>
<summary>Beispiel</summary>

```python
async def test_function(
        self, prompt: str, __user__: dict, __event_emitter__=None
    ) -> str:
        """
        Dies ist eine Demo

        :param test: Dies ist ein Testparameter
        """

        await __event_emitter__(
                    {
                        "type": "message", # Wir setzen hier den Typ
                        "data": {"content": "Diese Nachricht wird dem Chat hinzugef√ºgt."},
                        # Beachten Sie, dass wir bei Nachrichtentypen keine Bedingung f√ºr "done" setzen m√ºssen
                    }
                )

        except Exception as e:
            await __event_emitter__(
                {
                    "type": "status",
                    "data": {"description": f"Ein Fehler ist aufgetreten: {e}", "done": True},
                }
            )

            return f"Dem Benutzer mitteilen: {e}"
```
</details>

#### Zitate
Dieser Typ wird verwendet, um Zitate oder Referenzen im Chat bereitzustellen. Sie k√∂nnen ihn nutzen, um den Inhalt, die Quelle und alle relevanten Metadaten zu spezifizieren. Nachfolgend ein Beispiel, wie man ein Zitatereignis ausl√∂st:

```python
await __event_emitter__(
    {
        "type": "citation",
        "data": {
            "document": [content],
            "metadata": [
                {
                    "date_accessed": datetime.now().isoformat(),
                    "source": title,
                }
            ],
            "source": {"name": title, "url": url},
        },
    }
)
```
Falls mehrere Zitate gesendet werden, k√∂nnen Sie √ºber die Zitate iterieren und den Emitter mehrfach aufrufen. Bei der Implementierung benutzerdefinierter Zitate stellen Sie sicher, dass Sie `self.citation = False` in Ihrer `Tools`-Klasse im `__init__`-Methodenblock setzen. Andernfalls √ºberschreiben die eingebauten Zitate die von Ihnen gesendeten. Zum Beispiel:

```python
def __init__(self):
    self.citation = False
```

Warnung: Falls Sie `self.citation = True` setzen, ersetzt dies alle benutzerdefinierten Zitate, die Sie senden, mit dem automatisch generierten R√ºckgabezitat. Durch das Deaktivieren k√∂nnen Sie Ihre eigenen Zitierreferenzen vollst√§ndig verwalten.

<details>
<summary>Beispiel</summary>

```python
class Tools:
    class UserValves(BaseModel):
        test: bool = Field(
            default=True, description="test"
        )

    def __init__(self):
        self.citation = False

async def test_function(
        self, prompt: str, __user__: dict, __event_emitter__=None
    ) -> str:
        """
        Dies ist eine Demo, die nur ein Zitat erstellt

        :param test: Dies ist ein Testparameter
        """

        await __event_emitter__(
            {
                "type": "citation",
                "data": {
                    "document": ["Diese Nachricht wird dem Chat als Zitat hinzugef√ºgt, wenn darauf geklickt wird"],
                    "metadata": [
                        {
                            "date_accessed": datetime.now().isoformat(),
                            "source": title,
                        }
                    ],
                    "source": {"name": "Titel des Inhalts", "url": "http://link-zu-zitat"},
                },
            }
        )
```
</details>

## Externe Pakete

In den Metadaten der Tools-Definition k√∂nnen Sie benutzerdefinierte Pakete spezifizieren. Wenn Sie auf `Speichern` klicken, wird die Zeile analysiert und `pip install` f√ºr alle Anforderungen gleichzeitig ausgef√ºhrt.

Beachten Sie, dass Open WebUI w√§hrend der Installation komplett unresponsive sein wird, da `pip` im selben Prozess verwendet wird.

Es werden keine Ma√ünahmen ergriffen, um Paketkonflikte mit den Anforderungen von Open WebUI zu behandeln. Das bedeutet, dass das Festlegen von Anforderungen Open WebUI brechen kann, wenn Sie nicht vorsichtig sind. Sie k√∂nnten versuchen, dies zu umgehen, indem Sie `open-webui` selbst als Anforderung festlegen.


<details>
<summary>Beispiel</summary>

```python
"""
title: myToolName
author: meinName
funding_url: [Ein beliebiger Link hier wird hinter einer `Herz`-Schaltfl√§che angezeigt, damit Benutzer ihre Unterst√ºtzung zeigen k√∂nnen]
version: 1.0.0
# Die Version wird in der UI angezeigt, damit Benutzer √ºber Updates informiert bleiben.
license: GPLv3
description: [empfohlen]
requirements: package1>=2.7.0,package2,package3
"""
```

</details>

---
sidebar_position: 3
title: "üîÑ Valves"
---

## Vannes

Les vannes et les UserValves sont utilis√©es pour permettre aux utilisateurs de fournir des d√©tails dynamiques tels qu'une cl√© API ou une option de configuration. Cela cr√©e un champ remplissable ou un interrupteur bool√©en dans le menu GUI pour la fonction donn√©e. Ils sont toujours optionnels, mais FORTEMENT encourag√©s.

Ainsi, les classes Valves et UserValves peuvent √™tre d√©finies dans une classe `Pipe`, `Pipeline`, `Filter` ou `Tools`.

Les vannes sont configurables uniquement par les administrateurs via les menus Outils ou Fonctions. En revanche, les UserValves sont configurables par tous les utilisateurs directement pendant une session de chat.

<details>
<summary>Exemple comment√©</summary>

```python

from pydantic import BaseModel, Field
from typing import Literal

# D√©finir les vannes
class Filter:
   # Remarque sur l'indentation actuelle : les vannes et UserValves doivent √™tre d√©clar√©es comme
   # attributs d'une classe Tools, Filter ou Pipe. Ici, nous prenons
   # l'exemple d'un filtre.
    class Valves(BaseModel):
       # Les Valves et UserValves h√©ritent de BaseModel de pydantic. Cela
       # permet des cas d'utilisation complexes tels que des validateurs de mod√®les, etc.
       test_valve: int = Field(  # Remarque sur la suggestion de type : elle est utilis√©e pour
           # choisir le type d'√©l√©ment d'interface utilisateur √† montrer √† l'utilisateur (boutons,
           # textes, etc).
           default=4,
           description="Une vanne contr√¥lant une valeur num√©rique"
           # required=False,  # vous pouvez imposer des champs en utilisant True
       )
       # Pour offrir √† l'utilisateur le choix entre plusieurs cha√Ænes, vous pouvez utiliser Literal de typing :
       choice_option: Literal["choiceA", "choiceB"] = Field(
           default="choiceA",
           description="Un exemple de vanne √† choix multiple",
       )
       priority: int = Field(
           default=0,
           description="Niveau de priorit√© pour les op√©rations de filtrage. Les valeurs basses passent en premier"
       )
       # Le champ de priorit√© est facultatif, mais s'il est pr√©sent, il sera utilis√© pour
       # ordonner les filtres.
       pass
       # Notez que ce 'pass' aide au parsing et est recommand√©.

   # Les UserValves sont d√©finies de la m√™me mani√®re.
    class UserValves(BaseModel):
        test_user_valve: bool = Field(
            default=False, description="Une vanne utilisateur contr√¥lant un interrupteur True/False (marche/arr√™t)"
       )
       pass

   def __init__(self):
       self.valves = self.Valves()
       # √âtant donn√© qu'elles sont d√©finies par l'administrateur, elles sont accessibles directement
       # √† l'ex√©cution du code.
       pass

   # La m√©thode inlet est uniquement utilis√©e pour Filter mais la gestion de __user__ est la m√™me
   def inlet(self, body: dict, __user__: dict):
       # √âtant donn√© que les UserValves sont d√©finies pour chaque utilisateur, elles sont uniquement disponibles
       # lors de l'utilisation.
       # Notez que bien que __user__ soit un dict, __user__["valves"] est un
       # objet UserValves. Ainsi, vous pouvez acc√©der aux valeurs comme ceci :
       test_user_valve = __user__["valves"].test_user_valve
       # Ou :
       test_user_valve = dict(__user__["valves"])["test_user_valve"]
       # Mais cela retournera la valeur par d√©faut plut√¥t que la valeur r√©elle :
       # test_user_valve = __user__["valves"]["test_user_valve"]  # Ne faites pas √ßa !
```

</details>

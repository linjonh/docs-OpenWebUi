---
sidebar_position: 2
title: "ğŸª„ FunciÃ³n de Filtro"
---

# ğŸª„ FunciÃ³n de Filtro: Modificar Entradas y Salidas

Â¡Bienvenido a la guÃ­a completa sobre las Funciones de Filtro en Open WebUI! Los filtros son un sistema de **plugins flexible y poderoso** para modificar los datos *antes de ser enviados al Modelo de Gran Lenguaje (LLM)* (entrada) o *despuÃ©s de ser devueltos del LLM* (salida). Ya sea que estÃ©s transformando entradas para brindar un mejor contexto o limpiando las salidas para mejorar la legibilidad, las **Funciones de Filtro** te permiten hacerlo todo.

Esta guÃ­a desglosarÃ¡ **quÃ© son los filtros**, cÃ³mo funcionan, su estructura, y todo lo que necesitas saber para construir filtros poderosos y fÃ¡ciles de usar por tu cuenta. Vamos a profundizar, y no te preocupesâ€”utilizarÃ© metÃ¡foras, ejemplos y consejos para que todo sea muy claro. ğŸŒŸ

---

## ğŸŒŠ Â¿QuÃ© Son los Filtros en Open WebUI?

Imagina Open WebUI como un **flujo de agua** que pasa por tuberÃ­as:

- Los **inputs de los usuarios** y las **salidas del LLM** son el agua.
- Los **filtros** son las **etapas de tratamiento del agua** que limpian, modifican y adaptan el agua antes de que alcance su destino final.

Los filtros estÃ¡n en el medio del flujoâ€”como puntos de controlâ€”donde decides quÃ© debe ajustarse.

AquÃ­ hay un resumen rÃ¡pido de lo que hacen los filtros:

1. **Modificar los Inputs de Usuarios (FunciÃ³n de Entrada)**: Ajusta los datos de entrada antes de que lleguen al modelo de IA. AquÃ­ se mejora la claridad, se aÃ±ade contexto, se sanitiza el texto o se reformatean los mensajes para cumplir con requisitos especÃ­ficos.
2. **Interceptar las Salidas del Modelo (FunciÃ³n de Flujo)**: Captura y ajusta las respuestas de la IA **mientras son generadas** por el modelo. Esto es Ãºtil para modificaciones en tiempo real, como filtrar informaciÃ³n sensible o dar formato a la salida para mejorar la legibilidad.
3. **Modificar las Salidas del Modelo (FunciÃ³n de Salida)**: Ajusta la respuesta de la IA **despuÃ©s de ser procesada**, antes de mostrarla al usuario. Esto puede ayudar a refinar, registrar o adaptar los datos para una experiencia de usuario mÃ¡s limpia.

> **Concepto Clave:** Los filtros no son modelos independientes, sino herramientas que mejoran o transforman los datos que viajan *hacia* y *desde* los modelos.

Los filtros son como **traductores o editores** en el flujo de trabajo de IA: puedes interceptar y cambiar la conversaciÃ³n sin interrumpir el flujo.

---

## ğŸ—ºï¸ Estructura de una FunciÃ³n de Filtro: El Esqueleto

Empecemos con la representaciÃ³n mÃ¡s simple de una FunciÃ³n de Filtro. No te preocupes si algunas partes parecen tÃ©cnicas al principioâ€”Â¡lo desglosaremos paso a paso!

### ğŸ¦´ Esqueleto BÃ¡sico de un Filtro

```python
from pydantic import BaseModel
from typing import Optional

class Filter:
    # VÃ¡lvulas: Opciones de configuraciÃ³n para el filtro
    class Valves(BaseModel):
        pass

    def __init__(self):
        # Inicializa las vÃ¡lvulas (configuraciÃ³n opcional para el filtro)
        self.valves = self.Valves()

    def inlet(self, body: dict) -> dict:
        # AquÃ­ es donde manipulas las entradas del usuario.
        print(f"inlet llamado: {body}")
        return body

    def stream(self, event: dict) -> dict:
        # AquÃ­ es donde modificas los fragmentos transmitidos de la salida del modelo.
        print(f"evento de flujo: {event}")
        return event

    def outlet(self, body: dict) -> None:
        # AquÃ­ es donde manipulas las salidas del modelo.
        print(f"outlet llamado: {body}")
```

---

### ğŸ†• ğŸ§² Ejemplo de Filtro con Interruptor: AÃ±adiendo Interactividad e Iconos (Nuevo en Open WebUI 0.6.10)

Los filtros pueden hacer mÃ¡s que simplemente modificar textoâ€”pueden exponer interruptores en la interfaz de usuario y mostrar iconos personalizados. Por ejemplo, podrÃ­as querer un filtro que pueda activarse/desactivarse con un botÃ³n de la interfaz de usuario y muestre un icono especial en la interfaz de entrada de mensajes de Open WebUI.

AquÃ­ estÃ¡ cÃ³mo podrÃ­as crear un filtro con interruptor:

```python
from pydantic import BaseModel, Field
from typing import Optional

class Filter:
    class Valves(BaseModel):
        pass

    def __init__(self):
        self.valves = self.Valves()
        self.toggle = True # IMPORTANTE: Esto crea un interruptor en la interfaz de usuario de Open WebUI
        # CONSEJO: Â¡Usa URI de Datos SVG!
        self.icon = """data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIGZpbGw9Im5vbmUiIHZpZXdCb3g9IjAgMCAyNCAyNCIgc3Ryb2tlLXdpZHRoPSIxLjUiIHN0cm9rZT0iY3VycmVudENvbG9yIiBjbGFzcz0ic2l6ZS02Ij4KICA8cGF0aCBzdHJva2UtbGluZWNhcD0icm91bmQiIHN0cm9rZS1saW5lam9pbj0icm91bmQiIGQ9Ik0xMiAxOHYtNS4yNW0wIDBhNi4wMSA2LjAxIDAgMCAwIDEuNS0uMTg5bS0xLjUuMTg5YTYuMDEgNi4wMSAwIDAgMS0xLjUtLjE4OW0zLjc1IDcuNDc4YTEyLjA2IDEyLjA2IDAgMCAxLTQuNSAwbTMuNzUgMi4zODNhMTQuNDA2IDE0LjQwNiAwIDAgMS0zIDBNMTQuMjUgMTh2LS4xOTJjMC0uOTgzLjY1OC0xLjgyMyAxLjUwOC0yLjMxNmE3LjUgNy41IDAgMSAwLTcuNTE3IDBjLjg1LjQ5MyAxLjUwOSAxLjMzMyAxLjUwOSAyLjMxNlYxOCIgLz4KPC9zdmc+Cg=="""
        pass

    async def inlet(
        self, body: dict, __event_emitter__, __user__: Optional[dict] = None
    ) -> dict:
        await __event_emitter__(
            {
                "type": "estado",
                "data": {
                    "description": "Â¡Activado!",
                    "done": True,
                    "hidden": False,
                },
            }
        )
        return body
```

#### ğŸ–¼ï¸ Â¿QuÃ© estÃ¡ pasando?
- **toggle = True** crea una interfaz de interruptor en Open WebUI â€” los usuarios pueden habilitar o deshabilitar manualmente el filtro en tiempo real.
- **icon** (con un Data URI) aparecerÃ¡ como una pequeÃ±a imagen al lado del nombre del filtro. Â¡Puedes usar cualquier SVG mientras estÃ© codificado como Data URI!
- **La funciÃ³n `inlet`** utiliza el argumento especial `__event_emitter__` para transmitir comentarios/estado a la interfaz de usuario, como un pequeÃ±o mensaje/toast que dice "Â¡Activado!"

![Filtro con interruptor](/images/features/plugin/functions/toggle-filter.png)

Puedes usar estos mecanismos para hacer que tus filtros sean dinÃ¡micos, interactivos y visualmente Ãºnicos dentro del ecosistema de plugins de Open WebUI.

---

### ğŸ¯ Componentes Clave Explicados

#### 1ï¸âƒ£ **Clase `Valves` (ConfiguraciÃ³n Opcional)**

Piensa en **Valves** como perillas y deslizadores para tu filtro. Si quieres darles a los usuarios opciones configurables para ajustar el comportamiento de tu filtro, las defines aquÃ­.

```python
class Valves(BaseModel):
    OPTION_NAME: str = "Valor Predeterminado"
```

Por ejemplo:  
Si estÃ¡s creando un filtro que convierte las respuestas en mayÃºsculas, podrÃ­as permitir que los usuarios configuren si cada salida se convierte completamente en mayÃºsculas vÃ­a una vÃ¡lvula como `TRANSFORM_UPPERCASE: bool = True/False`.

---

#### 2ï¸âƒ£ **FunciÃ³n `inlet` (Preprocesamiento de Entrada)**


La funciÃ³n `inlet` es como **preparar comida antes de cocinar**. Imagina que eres un chef: antes de que los ingredientes se incluyan en la receta (el LLM en este caso), puedes lavar verduras, picar cebollas o sazonar la carne. Sin este paso, tu plato final podrÃ­a carecer de sabor, incluir productos sin lavar o simplemente ser inconsistente.

En el mundo de Open WebUI, la funciÃ³n `inlet` realiza este trabajo de preparaciÃ³n importante en la **entrada del usuario** antes de enviarla al modelo. Garantiza que la entrada sea tan limpia, contextual y Ãºtil como sea posible para que la IA la maneje.

ğŸ“¥ **Entrada**:  
- **`body`**: La entrada cruda de Open WebUI al modelo. Tiene el formato de una solicitud de chat-completaciÃ³n (normalmente un diccionario que incluye campos como los mensajes de la conversaciÃ³n, configuraciones del modelo y otros metadatos). Piensa en esto como los ingredientes de tu receta.

ğŸš€ **Tu tarea**:  
Modificar y devolver el `body`. La versiÃ³n modificada del `body` es con la que trabaja el LLM, asÃ­ que esta es tu oportunidad de aportar claridad, estructura y contexto a la entrada.


##### ğŸ³ Â¿Por quÃ© usarÃ­as el `inlet`?
1. **Agregar contexto**: AÃ±adir informaciÃ³n crucial automÃ¡ticamente a la entrada del usuario, especialmente si su texto es vago o incompleto. Por ejemplo, podrÃ­as aÃ±adir "Eres un asistente amigable" o "Ayuda a este usuario a resolver un problema de software."
   
2. **Formatear datos**: Si la entrada requiere un formato especÃ­fico, como JSON o Markdown, puedes transformarla antes de enviarla al modelo.

3. **Sanear la entrada**: Eliminar caracteres no deseados, eliminar sÃ­mbolos potencialmente daÃ±inos o confusos (como espacios en exceso o emojis) o reemplazar informaciÃ³n sensible.

4. **Optimizar la entrada del usuario**: Si la salida del modelo mejora con una guÃ­a adicional, puedes usar el `inlet` para insertar instrucciones aclaratorias automÃ¡ticamente.


##### ğŸ’¡ Ejemplos de casos de uso: PreparaciÃ³n de alimentos
###### ğŸ¥— Ejemplo 1: Agregar contexto del sistema
Supongamos que el LLM es un chef preparando un plato de cocina italiana, pero el usuario no ha mencionado "Esto es para cocina italiana." Puedes asegurarte de que el mensaje sea claro agregando este contexto antes de enviar los datos al modelo.

```python
def inlet(self, body: dict, __user__: Optional[dict] = None) -> dict:
    # Agregar mensaje de sistema para contexto italiano en la conversaciÃ³n
    context_message = {
        "role": "system",
        "content": "EstÃ¡s ayudando al usuario a preparar una comida italiana."
    }
    # Insertar el contexto al principio del historial de chat
    body.setdefault("messages", []).insert(0, context_message)
    return body
```

ğŸ“– **Â¿QuÃ© ocurre?**
- Cualquier entrada del usuario como "Â¿QuÃ© ideas buenas para cenar tienes?" ahora lleva el tema italiano porque hemos configurado el contexto del sistema. Es posible que cheesecake no aparezca como respuesta, pero seguro que pasta sÃ­.


###### ğŸ”ª Ejemplo 2: Limpiar entrada (Eliminar caracteres extraÃ±os)
Supongamos que la entrada del usuario parece desordenada o incluye sÃ­mbolos no deseados como `!!!`, lo que hace la conversaciÃ³n ineficiente o difÃ­cil de procesar para el modelo. Puedes limpiarla mientras conservas el contenido principal.

```python
def inlet(self, body: dict, __user__: Optional[dict] = None) -> dict:
    # Limpiar la Ãºltima entrada del usuario (del final de la lista messages)
    last_message = body["messages"][-1]["content"]
    body["messages"][-1]["content"] = last_message.replace("!!!", "").strip()
    return body
```

ğŸ“– **Â¿QuÃ© ocurre?**
- Antes: `"Â¿CÃ³mo puedo depurar este problema!!!"` â¡ï¸ Enviado al modelo como `"Â¿CÃ³mo puedo depurar este problema"`

Nota: El usuario siente lo mismo, pero el modelo procesa una consulta mÃ¡s limpia y fÃ¡cil de entender.


##### ğŸ“Š CÃ³mo `inlet` ayuda a optimizar la entrada para el LLM:
- Mejora la **precisiÃ³n** al aclarar consultas ambiguas.
- Hace que la IA sea **mÃ¡s eficiente** al eliminar ruido innecesario como emojis, etiquetas HTML o puntuaciÃ³n adicional.
- Garantiza la **consistencia** al formatear la entrada del usuario para que coincida con los patrones o esquemas esperados del modelo (como, por ejemplo, JSON para un caso de uso especÃ­fico).


ğŸ’­ **Piensa en `inlet` como el sous-chef en tu cocina**: garantiza que todo lo que ingresa al modelo (tu "receta" de IA) haya sido preparado, limpiado y sazonado a la perfecciÃ³n. Â¡Cuanto mejor sea la entrada, mejor serÃ¡ el resultado!

---

#### ğŸ†• 3ï¸âƒ£ **Hook `stream` (Nuevo en Open WebUI 0.5.17)**

##### ğŸ”„ Â¿QuÃ© es el Hook `stream`?
La **funciÃ³n `stream`** es una nueva caracterÃ­stica introducida en Open WebUI **0.5.17** que te permite **interceptar y modificar respuestas del modelo transmitidas** en tiempo real.

A diferencia de `outlet`, que procesa una respuesta completa, `stream` opera sobre **fragmentos individuales** a medida que se reciben del modelo.

##### ğŸ› ï¸ Â¿CuÃ¡ndo usar el Hook Stream?
- Modificar **respuestas transmitidas** antes de que se muestren a los usuarios.
- Implementar **censura o limpieza en tiempo real**.
- **Monitorizar datos transmitidos** para registro o depuraciÃ³n.

##### ğŸ“œ Ejemplo: Registro de fragmentos transmitidos

AsÃ­ es como puedes inspeccionar y modificar las respuestas LLM transmitidas:
```python
def stream(self, event: dict) -> dict:
    print(event)  # Imprimir cada fragmento entrante para inspecciÃ³n
    return event
```

> **Ejemplo de eventos transmitidos:**
```jsonl
{"id": "chatcmpl-B4l99MMaP3QLGU5uV7BaBM0eDS0jb","choices": [{"delta": {"content": "Hola"}}]}
{"id": "chatcmpl-B4l99MMaP3QLGU5uV7BaBM0eDS0jb","choices": [{"delta": {"content": "!"}}]}
{"id": "chatcmpl-B4l99MMaP3QLGU5uV7BaBM0eDS0jb","choices": [{"delta": {"content": " ğŸ˜Š"}}]}
```
ğŸ“– **Â¿QuÃ© ocurre?**
- Cada lÃ­nea representa un **pequeÃ±o fragmento** de la respuesta transmitida del modelo.
- El campo **`delta.content`** contiene el texto generado de manera progresiva.

##### ğŸ”„ Ejemplo: Filtrar emojis de los datos transmitidos
```python
def stream(self, event: dict) -> dict:
    for choice in event.get("choices", []):
        delta = choice.get("delta", {})
        if "content" in delta:
            delta["content"] = delta["content"].replace("ğŸ˜Š", "")  # Eliminar emojis
    return event
```
ğŸ“– **Antes:** `"Hola ğŸ˜Š"`  
ğŸ“– **DespuÃ©s:** `"Hola"`

---

#### 4ï¸âƒ£ **FunciÃ³n `outlet` (Post-procesamiento de la Salida)**

La funciÃ³n `outlet` es como un **corrector**: organiza la respuesta de la IA (o realiza cambios finales) *despuÃ©s de que haya sido procesada por el LLM.*

ğŸ“¤ **Entrada**:
- **`body`**: Esto contiene **todos los mensajes actuales** en el chat (historial del usuario + respuestas del LLM).

ğŸš€ **Tu tarea**: Modificar este `body`. Puedes limpiar, agregar o registrar cambios, pero ten en cuenta cÃ³mo cada ajuste impacta la experiencia del usuario.

ğŸ’¡ **Mejores prÃ¡cticas**:
- Prefiere registrar en lugar de realizar ediciones directas en `outlet` (por ejemplo, para depuraciÃ³n o anÃ¡lisis).
- Si se necesitan modificaciones importantes (como formatear salidas), considera usar la funciÃ³n **pipe** en su lugar.

ğŸ’¡ **Caso de uso ejemplo**: Eliminar respuestas sensibles de API que no deseas que el usuario vea:
```python
def outlet(self, body: dict, __user__: Optional[dict] = None) -> dict:
    for message in body["messages"]:
        message["content"] = message["content"].replace("<API_KEY>", "[REDACTADO]")
    return body 
```

---

## ğŸŒŸ Filtros en acciÃ³n: Construyendo ejemplos prÃ¡cticos

Â¡Construyamos algunos ejemplos del mundo real para ver cÃ³mo usarÃ­as los filtros!

### ğŸ“š Ejemplo #1: AÃ±adir contexto a cada entrada del usuario

Â¿Quieres que el LLM siempre sepa que estÃ¡ ayudando a un cliente a solucionar problemas de software? Puedes agregar instrucciones como **"Eres un asistente de resoluciÃ³n de problemas de software"** a cada consulta del usuario.

```python
class Filter:
    def inlet(self, body: dict, __user__: Optional[dict] = None) -> dict:
        context_message = {
            "role": "system", 
            "content": "Eres un asistente de resoluciÃ³n de problemas de software."
        }
        body.setdefault("messages", []).insert(0, context_message)
        return body
```

---

### ğŸ“š Ejemplo #2: Resaltar salidas para facilitar la lectura

Â¿Devolver una salida en Markdown u otro estilo formateado? Â¡Usa la funciÃ³n `outlet`!

```python
class Filter:
    def outlet(self, body: dict, __user__: Optional[dict] = None) -> dict:
        # AÃ±adir Markdown de "resaltado" para cada respuesta
        for message in body["messages"]:
            if message["role"] == "assistant":  # Apuntar a la respuesta del modelo
                message["content"] = f"**{message[content]}**"  # Resaltar con Markdown
        return body
```

---

## ğŸš§ Posibles confusiones: Preguntas frecuentes claras ğŸ›‘

### **P: Â¿En quÃ© se diferencian los filtros de las funciones Pipe?**

Los filtros modifican datos **que van hacia** y **vienen de los modelos**, pero no interactÃºan significativamente con la lÃ³gica fuera de estas fases. Los pipes, por otro lado:
- Pueden integrar **APIs externas** o transformar significativamente cÃ³mo el backend maneja las operaciones.
- Exponen lÃ³gica personalizada como "modelos" completamente nuevos.

### **P: Â¿Puedo hacer un post-procesamiento intenso dentro de `outlet`?**

Puedes hacerlo, pero **no es la mejor prÃ¡ctica.**:
- **Los filtros** estÃ¡n diseÃ±ados para realizar cambios ligeros o aplicar registros.
- Si se requieren modificaciones significativas, considera una **FunciÃ³n de TuberÃ­a** en su lugar.

---

## ğŸ‰ Resumen: Â¿Por quÃ© construir funciones de filtro?

Hasta ahora, has aprendido:
1. **Inlet** manipula **entradas de usuario** (preprocesamiento).
2. **Stream** intercepta y modifica **los flujos de salida del modelo** (en tiempo real).
3. **Outlet** ajusta **las salidas de la IA** (postprocesamiento).
4. Los filtros son ideales para alteraciones ligeras y en tiempo real del flujo de datos.
5. Con **Valves**, empoderas a los usuarios para configurar Filtros dinÃ¡micamente y conseguir un comportamiento personalizado.

---

ğŸš€ **Tu turno**: Â¡Comienza a experimentar! Â¿QuÃ© pequeÃ±a modificaciÃ³n o adiciÃ³n de contexto podrÃ­a mejorar tu experiencia con Open WebUI? Â¡Los filtros son divertidos de construir, flexibles de usar y pueden llevar tus modelos al siguiente nivel!

Â¡Feliz programaciÃ³n! âœ¨
